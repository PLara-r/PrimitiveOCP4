# PrimitiveOCP4

1)Работа с примитивами

До сих пор мы использовали классы-обертки, когда нам нужны были примитивы для потоков. Мы сделали это с помощью CollectionsAPI, чтобы оно было естественным. С потоками, существуют также эквиваленты , что работа с int, doubleи longпримитивов. Давайте посмотрим, зачем это нужно. Предположим, что мы хотим вычислить сумму чисел в конечном потоке:

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n));
Неплохо. Было не сложно написать сокращение. Запустили аккумулятор с нуля. Затем мы добавили каждое число к этому промежуточному итогу по мере его появления в потоке. Есть еще один способ сделать это:

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum());
На этот раз мы преобразовали нашу Stream<Integer>в IntStreamи попросили IntStreamвычислить сумму для нас. Примитивные потоки знают, как автоматически выполнять определенные общие операции.
Пока это кажется приятным, но не очень важным. Теперь подумайте, как бы вы вычислили среднее значение. Вам нужно разделить сумму на количество элементов. Проблема в том, что потоки допускают только один проход. Java признает, что вычисление среднего значения является обычным делом, и предоставляет метод для вычисления среднего по потоковым классам для примитивов:

IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble());
Можно не только рассчитать среднее значение, но и сделать это легко. Очевидно, примитивные потоки важны. Мы рассмотрим создание и использование таких потоков, включая дополнительные и функциональные интерфейсы. 
 Создание примитивных потоков
Вот три типа примитивных потоков:
•	IntStream: Используется для примитивных типов int, short, byte, иchar
•	LongStream: Используется для примитивного типа long
•	DoubleStream: Используется для примитивных типов doubleиfloat
Почему у каждого примитивного типа нет своего собственного примитивного потока? Эти три являются наиболее распространенными, поэтому разработчики API пошли с ними.    
 Когда вы видите поток слов на экзамене, обратите внимание на случай. С заглавной буквы S или в коде Stream- это имя класса, который содержит Objectтип. С помощью строчных с , поток представляет собой концепцию , которая может быть Stream, DoubleStream, IntStreamили LongStream.
Некоторые из методов для создания примитивного потока эквивалентны тому, как мы создали источник для регулярного Stream. Вы можете создать пустой поток с этим:

DoubleStream empty = DoubleStream.empty();
Другой способ - использовать of()метод factory из одного значения или с помощью перегрузки varargs:

DoubleStream oneValue = DoubleStream.of(3.14);
DoubleStream varargs = DoubleStream.of(1.0, 1.1, 1.2);
oneValue.forEach(System.out::println);
System.out.println();
varargs.forEach(System.out::println);

Этот код выводит следующее:
3.14
 1.0
1.1
1.2
Он работает одинаково для каждого типа примитивного потока. Вы также можете использовать два метода для создания бесконечных потоков, как мы это делали с Stream:

DoubleStream random = DoubleStream.generate(Math::random);
DoubleStream fractions = DoubleStream.iterate(.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
System.out.println();
fractions.limit(3).forEach(System.out::println);
Поскольку потоки бесконечны, мы добавили промежуточную операцию ограничения, чтобы вывод не печатал значения вечно. Первый поток вызывает статический метод Mathдля получения случайного двойного числа. Так как числа случайны, ваш вывод, очевидно, будет другим. Второй поток продолжает создавать меньшие числа, каждый раз деля предыдущее значение на два. Результат, когда мы запустили этот код, был следующим:

0.07890654781186413
0.28564363465842346
0.6311403511266134
 0.5
0.25
0.125
Вам не нужно знать это для экзамена, но Randomкласс предоставляет метод для прямого получения потоков примитивов случайных чисел. Интересный факт! Например, ints()генерирует бесконечный поток intпримитивов.
Когда имеешь дело с intили longпримитивами, это часто считается. Предположим, что нам нужен поток с номерами от 1 до 5. Мы могли бы написать это, используя то, что мы уже объяснили:

IntStream count = IntStream.iterate(1, n -> n+1).limit(5);
count.forEach(System.out::println);
Этот код выводит цифры 1–5, по одному в каждой строке. Тем не менее, много кода, чтобы сделать что-то так просто. Java предоставляет метод, который может генерировать диапазон чисел:

IntStream range = IntStream.range(1, 6);
range.forEach(System.out::println);
Это лучше. range()Метод указывает на то, что мы хотим , чтобы число 1-6, не включая номер 6. Однако, он все еще может быть яснее. Мы хотим цифры 1–5. Мы должны быть в состоянии напечатать число 5, и мы можем сделать это следующим образом:

IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::println);
Даже лучше. На этот раз мы заявили, что хотим закрытый диапазон или инклюзивный диапазон. Этот метод лучше соответствует тому, как мы выражаем диапазон чисел простым английским языком.
Последний способ создания примитивного потока - сопоставление с другим типом потока. Таблица 4.6 показывает, что существует метод для отображения между любыми типами потоков .;
Таблица 4.6 Методы отображения между типами потоков

Класс исходного потока	Создавать  Stream	Создавать DoubleStream	Создавать IntStream	Создавать LongStream
Stream	map	mapToDouble	mapToInt	mapToLong
DoubleStream	mapToObj	map	mapToInt          	mapToLong
IntStream	mapToObj	mapToDouble	map	mapToLong
LongStream	mapToObj	mapToDouble	mapToInt	map

Очевидно, они должны быть совместимыми типами, чтобы это работало. Java требует, чтобы функция отображения была предоставлена как параметр, например:

Stream<String> objStream = Stream.of("penguin", "fish");
Эта функция, которая принимает Object, которая является Stringв этом случае. Функция возвращает int. Отображения функций здесь интуитивно понятны. Они берут тип источника и возвращают тип цели. В этом примере фактическим типом функции является ToIntFunction. 
Таблица 4.7 показывает имена отображающих функций. Как видите, они делают то, что вы могли ожидать.Таблица 4.7. Параметры функций при отображении между типами потоков
Класс исходного потока	Создавать  Stream	Создавать DoubleStream	Создавать IntStream	Создавать LongStream
Stream	Function	ToDoubleFunction	ToIntFunction	ToLongFunction
DoubleStream	Double 
Function	DoubleUnary 
Operator	DoubleToInt 
Function	DoubleToLong
 Function
IntStream	IntFunction	IntToDouble
 Function	IntUnary Operator	IntToLong Function
LongStream	Long Function	LongToDouble
 Function	LongToInt 
Function	LongUnary Operator
Вы должны запомнить Таблицу 4.6 и Таблицу 4.7 . Это не так сложно, как может показаться. В именах есть шаблоны, если вы помните несколько правил. Для Таблицы 4.6 сопоставление с тем же типом, с которого вы начали, просто вызывается map(). При возврате потока объекта, метод mapToObj(). Кроме того, это имя типа примитива в имени метода карты.
Для Таблицы 4.7 вы можете начать думать о типах источника и цели. Когда целевой тип является объектом, вы удаляете его Toиз имени. Когда отображение соответствует тому типу, с которого вы начали, вы используете унарный оператор вместо функции для примитивных потоков. 
    Вы также можете создать примитивный поток из Stream, используя flatMapToInt (), flatMapToDouble () или flatMapToLong (). Например, IntStream ints = list.stream (). FlatMapToInt (x -> IntStream.of (x));
Использование опционально с примитивными потоками
Ранее в этой главе мы написали метод вычисления среднего значения int[]и пообещали лучший способ. Теперь, когда вы знаете о примитивных потоках, вы можете вычислить среднее значение в одной строке:

IntStream stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();
Тип возврата не тот Optional, к которому вы привыкли. Это новый тип называется OptionalDouble. Вы можете спросить, почему у нас отдельный тип? Почему бы просто не использовать Optional<Double>? Разница в том, что OptionalDoubleдля примитива и Optional<Double>для Doubleкласса оболочки. Работа с необязательным примитивным классом выглядит аналогично работе с Optionalсамим классом:

optional.ifPresent(System.out::println);
System.out.println(optional.getAsDouble());
System.out.println(optional.orElseGet(() -> Double.NaN));
Единственная заметная разница в том, что мы позвонили, getAsDouble()а не get(). Это дает понять, что мы работаем с примитивом. Кроме того, orElseGet()принимает DoubleSupplierвместо Supplier.
Как и в случае с примитивными потоками, для примитивов существует три класса, зависящих от типа. Таблица 4.8 показывает незначительные различия между тремя. Вы, вероятно, не будете удивлены, что вы должны запомнить это также. Это действительно легко запомнить, поскольку единственное, что меняется, - это примитивное имя. Как вы должны помнить из раздела операций с терминалами, несколько потоковых методов возвращают необязательный параметр, такой как min()или findAny(). Каждый из них возвращает соответствующий необязательный тип. Реализации примитивного потока также добавляют два новых метода, которые вам нужно знать. sum()Метод не возвращает необязательный. Если вы попытаетесь добавить пустой поток, вы просто получите ноль. avg()Метод всегда возвращает OptionalDouble, так как в среднем потенциально может иметь дробные данные любого типа.
Таблица 4.8. Необязательные типы примитивов

	OptionalDouble	OptionalInt	OptionalLong
Начало как примитив
Getting as a primitive	getAsDouble()	getAsInt()	getAsLong()
orElseGet()  тип параметра
orElseGet()  parameter type	DoubleSupplier	IntSupplier	LongSupplier
Тип возврата max()
Return type of max()	OptionalDouble	OptionalInt	OptionalLong
Return type of sum()	double	int	long
Return type of avg()	OptionalDouble	OptionalDouble	OptionalDouble

Давайте попробуем пример, чтобы убедиться, что вы понимаете это:

5:    LongStream longs = LongStream.of(5, 10);
6:    long sum = longs.sum();
7:    System.out.println(sum); // 15 
8:    DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9:    OptionalDouble min = doubles.min(); // runs infinitely
Строка 5 создает поток longпримитивов с двумя элементами. Строка 6 показывает, что мы не используем опциональное значение для вычисления суммы. Строка 8 создает бесконечный поток doubleпримитивов. Строка 9 напоминает вам, что вопрос о коде, который выполняется бесконечно, может появиться и с примитивными потоками.  
Обобщающая статистика
Вы узнали достаточно, чтобы иметь возможность получить максимальное значение из потока intпримитивов. Если поток пуст, мы хотим вызвать исключение:

private static int max(IntStream ints) { 
  OptionalInt optional = ints.max(); 
  return optional.orElseThrow(RuntimeException::new);}
Это должно быть старая шляпа к настоящему времени. Мы получили, OptionalIntпотому что у нас есть IntStream. Если необязательный параметр содержит значение, мы его возвращаем. В противном случае мы бросаем новый RuntimeException.
Теперь мы хотим изменить метод, чтобы взять IntStreamи вернуть диапазон. Диапазон - это минимальное значение, вычитаемое из максимального значения. Ой-ой. Оба min()и max()являются терминальными операциями, что означает, что они используют поток при запуске. Мы не можем запустить две терминальные операции для одного и того же потока. К счастью, это общая проблема, и примитивные потоки решают ее для нас с помощью сводной статистики. Statisticэто просто большое слово для числа, которое было рассчитано на основе данных.

private static int range(IntStream ints) { 
  IntSummaryStatistics stats = ints.summaryStatistics(); 
  if (stats.getCount() == 0) throw new RuntimeException();  
 return stats.getMax()—stats.getMin();
}
Здесь мы попросили Java выполнить много вычислений о потоке. Это включает в себя минимальное, максимальное, среднее, размер и количество значений в потоке. Если бы поток был пустым, у нас был бы нулевой счет. В противном случае мы можем получить минимум и максимум из резюме.  
Изучение функциональных интерфейсов для примитивов
Помните, когда мы сказали вам запомнить таблицу 4.1 с общими функциональными интерфейсами в начале главы? А вы? Если ты этого не сделал, иди сделай это сейчас. Мы собираемсясделать это более вовлеченным. Так же, как существуют специальные потоки и необязательные классы для примитивов, существуют также специальные функциональные интерфейсы.
К счастью, большинство из них является для double, intи longтипов , которые вы видели , для потоков и дополнительных опций. Есть одно исключение, которое есть BooleanSupplier. Мы рассмотрим , что прежде чем вводить те , для double, intи long.
Функциональные интерфейсы для логического
BooleanSupplierэто отдельный тип. У него есть один метод для реализации:

boolean getAsBoolean()
Он работает так же, как вы ожидаете от функциональных интерфейсов, например:

12:   BooleanSupplier b1 = () -> true;
13:   BooleanSupplier b2 = () -> Math.random() > .5;
14:   System.out.println(b1.getAsBoolean());
15:   System.out.println(b2.getAsBoolean());
Строки 12 и 13 каждая создают a BooleanSupplier, который является единственным функциональным интерфейсом для boolean. Строка 14 печатается true, так как это результат b1. Строка 15 печатает trueили false, в зависимости от сгенерированного случайного значения.  
Функциональные интерфейсы для double , int и long
Большинство функциональных интерфейсов для double, intи longв соответствии с ручьями и что мы УСТРОЙСТВО уже использовали для примитивов. 
Таблица 4.9 показывает эквивалент Таблицы 4.1 для этих примитивов. Вы, вероятно, не будете удивлены, что вы должны запомнить это. К счастью, вы уже запомнили таблицу 4.1 и можете применить то, что вы узнали, к таблице 4.9 .
Таблица 4.9. Общие функциональные интерфейсы для примитивов



Functional Interfaces	# Parameters	Return Type	Single Abstract Method
DoubleSupplier 
IntSupplier 
LongSupplier	0	Double
 int 
long	getAsDouble
 getAsInt 
getAsLong
DoubleConsumer 
IntConsumer 
LongConsumer	1 (double) 
1 (int) 
1 (long)	void	accept
DoublePredicate
 IntPredicate 
LongPredicate	1 (double) 
1 (int) 
1 (long)	boolean	test
DoubleFunction<R>
 IntFunction<R> 
LongFunction<R>	1 (double) 
1 (int) 
1 (long)	R	apply
DoubleUnaryOperator 
IntUnaryOperator 
LongUnaryOperator	1 (double) 
1 (int) 
1 (long)	Double
 int 
long	applyAsDouble 
applyAsInt 
applyAsLong
DoubleBinaryOperator
 IntBinaryOperator LongBinaryOperator	2 (double, double) 
2 (int, int) 
2 (long, long)	Double
 int 
long	applyAsDouble 
applyAsInt
 applyAsLong

Следует отметить несколько моментов, которые отличаются между Таблицей 4.1 и Таблицей 4.9 :
•	Обобщения отсутствуют в некоторых интерфейсах, поскольку имя типа сообщает нам, какой тип примитива используется. В других случаях, например IntFunction, требуется только универсальный тип возвращаемого значения.
•	Единственный абстрактный метод часто, но не всегда, переименовывается, чтобы отразить задействованный примитивный тип.
•	BiConsumer, BiPredicateИ BiFunctionне в таблице 4.9 . Разработчики API придерживались самых распространенных операций. Для примитивов функции с двумя различными типами параметров просто не часто используются.
В дополнение к эквивалентам в Таблице 4.1 , некоторые интерфейсы относятся к примитивам. Таблица 4.10 перечисляет их.
Таблица 4.10 Примитивно-специфические функциональные интерфейсы

Functional Interfaces	# Parameters	Return Type	Single Abstract Method
ToDoubleFunction<T> 
ToIntFunction<T> 
ToLongFunction<T>	1 (T)	double
 int l
ong	applyAsDouble
 applyAsInt
 applyAsLong
ToDoubleBiFunction<T, U>
 ToIntBiFunction<T, U> 
ToLongBiFunction<T, U>	2 (T, U)	double
 int 
long	applyAsDouble
 applyAsInt
 applyAsLong
DoubleToIntFunction 
DoubleToLongFunction 
IntToDoubleFunction 
IntToLongFunction 
LongToDoubleFunction 
LongToIntFunction	1 (double)
 1 (double)
 1 (int)
 1 (int)
 1 (long) 
1 (long)	Int
 long
double
 long 
double 
int	applyAsInt 
applyAsLong
applyAsDouble
 applyAsLong
 applyAsDouble 
applyAsInt
ObjDoubleConsumer<T>
 ObjIntConsumer<T> 
ObjLongConsumer<T>	2 (T, double) 
2 (T, int) 
2 (T, long)	void	accept

Мы использовали функциональные интерфейсы всю главу, поэтому вы должны хорошо понимать, как читать таблицу к настоящему времени. Давайте сделаем один пример, чтобы быть уверенным. Какой функциональный интерфейс вы бы использовали для заполнения пробела, чтобы компилировать следующий код?
double d = 1.0;
_________ f1 = x -> 1;
f1.applyAsInt(d);

Когда вы видите такой вопрос, ищите подсказки. Вы можете видеть, что рассматриваемый функциональный интерфейс принимает doubleпараметр и возвращает int. Вы также можете видеть, что у него есть единственный абстрактный метод с именем applyAsInt. Единственный функциональный интерфейс, отвечающий всем трем критериям DoubleToIntFunction. 

2) Возврат необязательно

Предположим, что вы проходите вводный урок Java и получите оценки 90 и 100 на первых двух экзаменах. Теперь мы спрашиваем вас, какова ваша средняя. Среднее значение рассчитывается путем сложения баллов и деления на количество баллов, поэтому вы получите (90 + 100) / 2. Это дает 190/2, поэтому вы отвечаете с 95. Отлично!
Теперь предположим, что вы проходите второй урок по Java, и это первый день занятий. Мы спрашиваем вас, каков ваш средний уровень в этом классе, который только начался. Вы еще не сдавали экзамены, поэтому вам нечего усреднять. Было бы неправильно сказать, что ваше среднее значение равно нулю. Это звучит плохо, и это не правда. Данных просто нет, поэтому у вас пока нет среднего значения.
Как мы выражаем этот ответ «мы не знаем» или «не применим» на Java? Начиная с Java 8, мы используем Optionalтип. An Optionalсоздается с использованием фабрики. Вы можете запросить пустое значение Optionalили передать значение для Optionalпереноса. Думайте о Optionalкак о коробке, в которой может быть что-то или она может быть пустой. На рисунке 4.1 показаны оба варианта.

Рисунок 4.1 Optional
Вот как кодировать наш средний метод:


10:   public static Optional<Double> average(int… scores) {
11:      if (scores.length == 0) return Optional.empty();
12:      int sum = 0;
13:      for (int score: scores) sum += score;
14:      return Optional.of((double) sum / scores.length);
15:   }
Строка 11 возвращает пустое значение, Optionalкогда мы не можем вычислить среднее значение. Строки 12 и 13 складывают оценки. Существует функциональный способ программирования этой математики, но мы вернемся к этому позже в этой главе. Фактически, весь метод может быть записан в одну строку, но это не научит вас, как Optionalработает! Линия 14 создает, Optionalчтобы обернуть среднее.
Вызов метода показывает, что находится в наших двух полях:

System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average());        // Optional.empty
Вы можете видеть, что один Optionalсодержит значение, а другой пустой. Обычно мы хотим проверить, есть ли значение и / или получить его из коробки. Вот один из способов сделать это:

20:   Optional<Double> opt = average(90, 100);
21:   if (opt.isPresent())
22:      System.out.println(opt.get()); // 95.0
Строка 21 проверяет, Optionalдействительно ли содержит значение. Линия 22 распечатывает это. Что делать, если мы не сделали проверку, и она Optionalбыла пуста?

26:   Optional<Double> opt = average();
27:   System.out.println(opt.get());  // bad
Мы получили бы исключение, так как внутри Optional:

java.util.NoSuchElementException: No value present
При создании Optional, обычно хочется использовать, emptyкогда значение равно null. Вы можете сделать это с помощью ifоператора или троичного оператора. Мы используем троичный оператор, чтобы убедиться, что вы помните, как он работает из ОСА:

Optional o = (value== null) ? Optional.empty(): Optional.of(value);
Если valueесть null, oназначается пустое Optional. В противном случае мы оборачиваем значение. Поскольку это такой распространенный шаблон, Java предоставляет метод фабрики для того же:

Optional o = Optional.ofNullable(value);
Это охватывает статические методы, о которых вам нужно знать Optional. В таблице 4.2 приведены большинство методов экземпляров, Optionalкоторые вам необходимо знать для сдачи экзамена. Есть несколько других, которые связаны с цепочкой. Мы рассмотрим это позже в этой главе.
Таблица 4.2 Optional Методы экземпляра

метод	Когда Optionalпусто	Когда OptionalСодержит Значение
get()	Бросает исключение	Возвращает значение
ifPresent(Consumer c)	Ничего не делает	Звонит Потребителю cсо значением
isPresent()	Возвращает false	Возвращает true
orElse(T other)	Возвращает otherпараметр	Возвращает значение
orElseGet(Supplier s)	Возвращает результат вызова  Supplier	Возвращает значение
orElseThrow(Supplier s)	Выдает исключение, созданное вызовом Supplier	Возвращает значение

Вы уже видели get()и isPresent(). Другие методы позволяют вам писать код, который использует Optionalодну строку без необходимости использования тернарного оператора. Это облегчает чтение кода. Вместо того, чтобы использовать ifоператор, который мы использовали при проверке среднего ранее, мы можем указать a, Consumerкоторый будет выполняться, когда есть значение внутри Optional. Когда нет, метод просто пропускает выполнение Consumer:

Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println);
Использование ifPresent()лучше выражает наши намерения. Мы хотим что-то сделать, если значение присутствует. Другие методы позволяют вам указать, что делать, если значение отсутствует. Есть три варианта:

30:   Optional<Double> opt = average();
31:   System.out.println(opt.orElse(Double.NaN));
32:   System.out.println(opt.orElseGet(() -> Math.random()));
33:   System.out.println(opt.orElseThrow(() -> new IllegalStateException()));
Это печатает что-то вроде следующего:

NaN
0.49775932295380165
Exception in thread "main" java.lang.IllegalStateException   
 at optional.Average.lambda$3(Average.java:56)   
 at optional.Average$$Lambda$5/455659002.get(Unknown Source)   
 at java.util.Optional.orElseThrow(Optional.java:290)
Строка 31 показывает, что вы можете вернуть определенное значение или переменную. В нашем случае мы печатаем значение «не число». В строке 32 показано использование a Supplierдля генерации значения во время выполнения для возврата. Я рад, что наши профессора не дали нам случайное среднее значение, хотя! Строка 33 показывает использование другого Supplierдля создания исключения, которое должно быть выброшено. Помните, что трассировка стека выглядит странно, потому что лямбда-выражения генерируются, а не именуются классы.
Обратите внимание, что два метода Supplierимеют разные имена. Вы понимаете, почему этот код не компилируется?

System.out.println(opt.orElseGet( 
 () -> new IllegalStateException())); // DOES NOT COMPILE
optявляется Optional<Double>. Это означает, что Supplierдолжен вернуть Double. Поскольку этот поставщик возвращает исключение, тип не соответствует.
Последний пример с Optionalдействительно прост. Как вы думаете, что это делает?

Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow(() -> new IllegalStateException()));
Распечатывается 95три раза. Поскольку значение существует, нет необходимости использовать логику «или иначе».
Является ли Optional таким же, как null ?
До Java 8 программисты возвращались nullвместо Optional. У этого подхода было несколько недостатков. Одна заключалась в том, что не было четкого способа выразить это, nullвозможно, особую ценность. Напротив, возвращение Optionalв API является четким утверждением о том, что там может не быть значения.
Еще одним преимуществом Optionalявляется то, что вы можете использовать функциональный стиль программирования с ifPresent()другими методами, а не с помощью ifоператора. Наконец, в конце главы вы увидите, что вы можете связывать Optionalвызовы.

